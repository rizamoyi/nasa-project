{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.default = jssExpand;\n\nvar _props = require('./props');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Map values by given prop.\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {String} original rule\n * @return {String} mapped values\n */\n\n\nfunction mapValuesByProp(value, prop, rule) {\n  return value.map(function (item) {\n    return objectToArray(item, prop, rule, false, true);\n  });\n}\n/**\n * Convert array to nested array, if needed\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {Object} sheme, for converting arrays in strings\n * @param {Object} original rule\n * @return {String} converted string\n */\n\n\nfunction processArray(value, prop, scheme, rule) {\n  if (scheme[prop] == null) return value;\n  if (value.length === 0) return [];\n  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme);\n\n  if (_typeof(value[0]) === 'object') {\n    return mapValuesByProp(value, prop, rule);\n  }\n\n  return [value];\n}\n/**\n * Convert object to array.\n *\n * @param {Object} object of values\n * @param {String} original property\n * @param {Object} original rule\n * @param {Boolean} is fallback prop\n * @param {Boolean} object is inside array\n * @return {String} converted string\n */\n\n\nfunction objectToArray(value, prop, rule, isFallback, isInArray) {\n  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return [];\n  var result = []; // Check if exists any non-standart property\n\n  if (_props.customPropObj[prop]) {\n    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);\n  } // Pass throught all standart props\n\n\n  if (Object.keys(value).length) {\n    for (var baseProp in _props.propObj[prop]) {\n      if (value[baseProp]) {\n        if (Array.isArray(value[baseProp])) {\n          result.push(_props.propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));\n        } else result.push(value[baseProp]);\n\n        continue;\n      } // Add default value from props config.\n\n\n      if (_props.propObj[prop][baseProp] != null) {\n        result.push(_props.propObj[prop][baseProp]);\n      }\n    }\n  }\n\n  if (!result.length || isInArray) return result;\n  return [result];\n}\n/**\n * Convert custom properties values to styles adding them to rule directly\n *\n * @param {Object} object of values\n * @param {Object} original rule\n * @param {String} property, that contain partial custom properties\n * @param {Boolean} is fallback prop\n * @return {Object} value without custom properties, that was already added to rule\n */\n\n\nfunction customPropsToStyle(value, rule, customProps, isFallback) {\n  for (var prop in customProps) {\n    var propName = customProps[prop]; // If current property doesn't exist already in rule - add new one\n\n    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {\n      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName]; // Add style directly in rule\n\n      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;\n    } // Delete converted property to avoid double converting\n\n\n    delete value[prop];\n  }\n\n  return value;\n}\n/**\n * Detect if a style needs to be converted.\n *\n * @param {Object} style\n * @param {Object} rule\n * @param {Boolean} is fallback prop\n * @return {Object} convertedStyle\n */\n\n\nfunction styleDetector(style, rule, isFallback) {\n  for (var prop in style) {\n    var value = style[prop];\n\n    if (Array.isArray(value)) {\n      // Check double arrays to avoid recursion.\n      if (!Array.isArray(value[0])) {\n        if (prop === 'fallbacks') {\n          for (var index = 0; index < style.fallbacks.length; index++) {\n            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);\n          }\n\n          continue;\n        }\n\n        style[prop] = processArray(value, prop, _props.propArray); // Avoid creating properties with empty values\n\n        if (!style[prop].length) delete style[prop];\n      }\n    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      if (prop === 'fallbacks') {\n        style.fallbacks = styleDetector(style.fallbacks, rule, true);\n        continue;\n      }\n\n      style[prop] = objectToArray(value, prop, rule, isFallback); // Avoid creating properties with empty values\n\n      if (!style[prop].length) delete style[prop];\n    } // Maybe a computed value resulting in an empty string\n    else if (style[prop] === '') delete style[prop];\n  }\n\n  return style;\n}\n/**\n * Adds possibility to write expanded styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\n\nfunction jssExpand() {\n  function onProcessStyle(style, rule) {\n    if (!style || rule.type !== 'style') return style;\n\n    if (Array.isArray(style)) {\n      // Pass rules one by one and reformat them\n      for (var index = 0; index < style.length; index++) {\n        style[index] = styleDetector(style[index], rule);\n      }\n\n      return style;\n    }\n\n    return styleDetector(style, rule);\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","default","jssExpand","_props","require","_defineProperty","key","enumerable","configurable","writable","mapValuesByProp","prop","rule","map","item","objectToArray","processArray","scheme","length","Array","isArray","isFallback","isInArray","propObj","customPropObj","result","customPropsToStyle","keys","baseProp","push","propArrayInObj","join","customProps","propName","appendedValue","styleDetector","style","fallbacks","index","propArray","onProcessStyle","type"],"sources":["/home/samkach/Desktop/node/nasa-project/client/node_modules/jss-expand/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = jssExpand;\n\nvar _props = require('./props');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Map values by given prop.\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {String} original rule\n * @return {String} mapped values\n */\nfunction mapValuesByProp(value, prop, rule) {\n  return value.map(function (item) {\n    return objectToArray(item, prop, rule, false, true);\n  });\n}\n\n/**\n * Convert array to nested array, if needed\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {Object} sheme, for converting arrays in strings\n * @param {Object} original rule\n * @return {String} converted string\n */\nfunction processArray(value, prop, scheme, rule) {\n  if (scheme[prop] == null) return value;\n  if (value.length === 0) return [];\n  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme);\n  if (_typeof(value[0]) === 'object') {\n    return mapValuesByProp(value, prop, rule);\n  }\n\n  return [value];\n}\n\n/**\n * Convert object to array.\n *\n * @param {Object} object of values\n * @param {String} original property\n * @param {Object} original rule\n * @param {Boolean} is fallback prop\n * @param {Boolean} object is inside array\n * @return {String} converted string\n */\nfunction objectToArray(value, prop, rule, isFallback, isInArray) {\n  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return [];\n\n  var result = [];\n\n  // Check if exists any non-standart property\n  if (_props.customPropObj[prop]) {\n    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);\n  }\n\n  // Pass throught all standart props\n  if (Object.keys(value).length) {\n    for (var baseProp in _props.propObj[prop]) {\n      if (value[baseProp]) {\n        if (Array.isArray(value[baseProp])) {\n          result.push(_props.propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));\n        } else result.push(value[baseProp]);\n        continue;\n      }\n\n      // Add default value from props config.\n      if (_props.propObj[prop][baseProp] != null) {\n        result.push(_props.propObj[prop][baseProp]);\n      }\n    }\n  }\n\n  if (!result.length || isInArray) return result;\n  return [result];\n}\n\n/**\n * Convert custom properties values to styles adding them to rule directly\n *\n * @param {Object} object of values\n * @param {Object} original rule\n * @param {String} property, that contain partial custom properties\n * @param {Boolean} is fallback prop\n * @return {Object} value without custom properties, that was already added to rule\n */\nfunction customPropsToStyle(value, rule, customProps, isFallback) {\n  for (var prop in customProps) {\n    var propName = customProps[prop];\n\n    // If current property doesn't exist already in rule - add new one\n    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {\n      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];\n\n      // Add style directly in rule\n      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;\n    }\n    // Delete converted property to avoid double converting\n    delete value[prop];\n  }\n\n  return value;\n}\n\n/**\n * Detect if a style needs to be converted.\n *\n * @param {Object} style\n * @param {Object} rule\n * @param {Boolean} is fallback prop\n * @return {Object} convertedStyle\n */\nfunction styleDetector(style, rule, isFallback) {\n  for (var prop in style) {\n    var value = style[prop];\n\n    if (Array.isArray(value)) {\n      // Check double arrays to avoid recursion.\n      if (!Array.isArray(value[0])) {\n        if (prop === 'fallbacks') {\n          for (var index = 0; index < style.fallbacks.length; index++) {\n            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);\n          }\n          continue;\n        }\n\n        style[prop] = processArray(value, prop, _props.propArray);\n        // Avoid creating properties with empty values\n        if (!style[prop].length) delete style[prop];\n      }\n    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      if (prop === 'fallbacks') {\n        style.fallbacks = styleDetector(style.fallbacks, rule, true);\n        continue;\n      }\n\n      style[prop] = objectToArray(value, prop, rule, isFallback);\n      // Avoid creating properties with empty values\n      if (!style[prop].length) delete style[prop];\n    }\n\n    // Maybe a computed value resulting in an empty string\n    else if (style[prop] === '') delete style[prop];\n  }\n\n  return style;\n}\n\n/**\n * Adds possibility to write expanded styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssExpand() {\n  function onProcessStyle(style, rule) {\n    if (!style || rule.type !== 'style') return style;\n\n    if (Array.isArray(style)) {\n      // Pass rules one by one and reformat them\n      for (var index = 0; index < style.length; index++) {\n        style[index] = styleDetector(style[index], rule);\n      }\n      return style;\n    }\n\n    return styleDetector(style, rule);\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}